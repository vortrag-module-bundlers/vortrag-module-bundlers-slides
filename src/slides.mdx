import { Image, FlexBox, Quote } from "spectacle";
import Test from "./test-component";
export const testProp = 50;

# Module Bundler im Frontend - das Warum und Wie

---

# Wof√ºr ben√∂tigt man einen Module Bundler?

---

# Wie laden Webbrowser traditionell Assets?

---

# Wie kann ein Entwickler Abh√§ngiogkeiten in einem Projekt aufl√∂sen?

---

# Manuell

```html
<body>
  <div>The normal content</div>

  <script src="lib1.js"></script>
  <script src="lib2.js"></script>
  <script src="dependency-of-lib3.js"></script>
  <script src="lib3.js"></script>
  <script src="script1.js"></script>
  <script src="script2.js"></script>
  <script src="script3.js"></script>
  <script src="script4.js"></script>
  <script src="script5.js"></script>
</body>
```

Disclaimer: So habe ich tats√§chlich angefangen Webanwendungen zu schreiben.

---

<FlexBox alignContent="center" justifyContent="center">
  <Image
    src="https://pbs.twimg.com/media/DB6QcoNVYAA-w6N:small?format=jpg"
    alt="Mozilla dependency graph"
    width="680px"
    height="530px"
  />
</FlexBox>

Das Problem ist, manuell Abh√§ngigkeiten pflegen ger√§t sehr schnell au√üer
Kontrolle ...

---

<FlexBox alignContent="center" justifyContent="center" height="100%">
  <Image
    src="https://media.giphy.com/media/QvMlVkJ3XSSj9cOxDM/source.gif"
    alt="Hell"
  />
</FlexBox>

---

# Globaler Namespace

Eine weitere Herausforderung von Importen via Script-Tags ist, standardm√§√üig wird alles aus der importierten Datei dem globalen Namespace hinzugef√ºgt.

Das Problem kann √ºber sogenannte [IIFE](https://developer.mozilla.org/de/docs/Glossary/IIFE) teilweise gel√∂st werden.

---

# Module Bundler

Um die Schwierigkeiten mit manuellen Importen zu beheben, wurden ab 2011 sogenannte Module Bundler wie [browserify](http://browserify.org/) oder [webpack](https://webpack.js.org/) entwickelt.

Diese Tools erm√∂glichen den Entwicklern, Code modular zu schreiben.
Das Aufl√∂sen der Abh√§ngigkeiten und der Zusammenbau von Quelldateien in ein f√ºr Browser verst√§ndliches Format wird von diesen Tools √ºbernommen.

---

# ECMAScript Module

[Moderne Browser](https://caniuse.com/es6-module) implementieren ein eigenes Modulsystem, genannt [ES Module](https://developer.mozilla.org/de/docs/Web/JavaScript/Guide/Modules).

Dieses erm√∂glich es Entwicklern, modulare Code zu schreiben und diesen unver√§ndert in Browsern auszuf√ºhren.
Der Browser selbst k√ºmmert sich darum, alle Anh√§ngigkeiten korrekt zu laden.

Damit entf√§llt - _theoretisch_ - die Notwendigkeit einen Bundler einzusetzen.

---

# Buildless

Tats√§chlich kann man heutzutage kleinere Projekte, die nur auf moderne Browser abzielen, ohne einen eigenen Buildprozess entwickeln.

Diese Art der Webentwicklung wird unter dem Begriff [buildless](https://buildless.site/) zusammengefasst.

---

# Aufgaben eines Module Bundlers heute

In der Praxis st√∂√üt man bei gr√∂√üeren Projekten (also alles was wir so machen) relativ schnell an technische Grenzen, wenn man komplett auf einen Buildprozess verzichtet.

Daher ist auch heutzutage der Einsatz eines Module Bundlers und einer Build-Pipeline meistens sinnvoll.

---

## Module Resolution

Unter module resolution versteht man das Aufl√∂sen der Abh√§ngigkeiten aller Quellcode Dateien untereinander.
Dabei wird ein sog. Abh√§ngigkeitsbaum aufgebaut und damit die korrekte Ladereihenfolge aller Dateien sichergestellt.

So ist jede abh√§ngige Datei bereits geladen, sobald sie ben√∂tigt wird und der Entwickler muss das nicht mehr manuell machen (dependency hell).

---

## Transpile

Unter den Begriff Tanspilierung versteht man das √úbersetzen einer Quelldatei von einer Hochsprache in eine andere Hochsprache.

Der Unterschied zu Kompilierung ist, dass dort eine Hochsprache (z.B. C++) in Maschinencode √ºbersetzt wird.

---

## Transpile

Heutzutage gibt es viele Sprachen, die auf die Web-Basistechnologien (HTML, CSS, JavaScript) aufsetzten und diese um neue M√∂glichkeiten erweitern.
Beliebte Beispiele hierf√ºr sind z.B. TypeScript (JavaScript), SASS und PostCSS (CSS) oder Pug (HTML).

Viele Module Bundler bieten Unterst√ºtzung f√ºr diese Sprachen und √ºbernehmen die √úbersetzung in HTML, CSS und JavaScript automatisch.

---

## Bundle

Der Bundle Schritt, der diesen Tools ihren Namen gibt, ist das B√ºndeln der einzelnen Quelldateien in eines oder wenige Code-Pakete.

Um den Browser und das Netzwerk nicht mit dem Herunterladen hunderter oder tausender einzelner Datein zu belasten, werden diese zu wenigen gro√üen Dateien zusammengefasst.

---

## Statische Assets verwalten

Statische Assets wie Bilder, JSON oder Manifest Dateien oder √§hnliche Dateien, die nicht direkt weiterverarbeitet werden, sind ebenfalls Teil des Build-Prozesses.

Der Module Bundler ist daf√ºr verantwortlich, diese in den endg√ºltigen Build abzulegen und auszuliefern.

---

## Development Tooling

- Dev server
- Source maps
- Statische Codeanalyse (Linter, Compiler)

---

## Production Build Optimierungen

W√§hrend der Development Build sich vor allem darauf konzentriert, den Entwicklern die Arbeit zu erleichtern,
ist die Aufgabe des Production Builds, die Anwendung f√ºr den Betrieb auf den Zielplattformen (den unterst√ºtzten Browsern) zu optimieren.

Hierf√ºr gibt es mehrere Schritte im Build, die w√§hrend der Entwicklung √ºblicherweise weggelassen werden.

---

### Minification

Der gebaute Quellcode wird in diesem Schritt durch ein Programm geschickt, das die Codemenge m√∂glichst reduzieren soll.
Zu diesem Zweck wird aller unnn√∂tiger Whitespace entfernt, Variablennamen gek√ºrzt oder Kommentare entfernt.

Ziel ist, die √ºber das Netzwerk zu √ºbertragende Menge an Bytes zu klein wie m√∂glich zu halten.

---

### Minification

Ein angenehmer Nebeneffekt ist, dass der Ergebniscode schlechter lesbar ist, also viel schwerer von Konkurrenten "ausgeliehen" werden kann.

```javascript
// vorher
const hello = (firstName, lastName) => {
  return `Hello ${firstName} ${lastName}`;
};

const helloWorld = (firstName, lastName) => {
  return `Hello world ${firstName} ${lastName}`;
};

// von https://terser.org/ geparst
const hello=(l,o)=>`Hello ${l} ${o}`,helloWorld=(l,o)=>`Hello world ${l} ${o}`;
```

---

### Tree shaking

Unter tree shaking versteht man das gezielte Entfernen nicht genutzen Codes aus dem Build. 

Beispiel:
In einer Codedatei sind drei Funktionen f1, f2 und f3 definiert. 
In der eigentlichen Anwendung wird aus dieser Datei jedoch nur die Funktion f2 importiert und verwendet. 

In Dev Build wird die Datei als Ganzes importiert, im Prod Build werden die Funktionen f1 und f3 entfernt und nicht ausgeliefert. 


---

### Code splitting

Code splitting stellt das Gegenteil zum Bundle Schritt dar. Viele einzelne Dateien auszuliefern ist nicht effizient, 
den gesamten Code in eine einzige Datei zu packen jedoch auch. 

So werden manche Teile des Codes oft nur an wenigen Stellen der Anwendung ben√∂tigt. Diese immer zu laden, obwohl der Benutzer 
diese Teile der Anwendung gar nicht nutzt, verz√∂gert das initiale Laden der Anwendung und verursacht unn√∂tigen Netzwerkverkehr. 

---

### Code splitting

Also stellen Bundler M√∂glichkeiten zur Verf√ºgung, bestimmte Teile des Codes in eigene Teilpakete auszulagern und diese nur 
bei Bedarf zu laden. 

---

### Dynamische Importe

Eine beleibte Methode stellen die sog. dynamischen Importe mit Hilfe der `import` Funktion dar, siehe z.B. [hier](https://2ality.com/2017/01/import-operator.html).

Inzwischen ist auch die [native Unterst√ºtzung](https://caniuse.com/es6-module-dynamic-import) von dynamischen Importen in den meisten Browsern angekommen, 
die nicht mehr auf Bundler angewiesen sind. 

---

### Optimierte Builds f√ºr moderne und legacy Browser

Sollte das Projekt noch legacy Browser (IE) unterst√ºtzen m√ºssen, gibt es zwei Strategien:

- Der Prod Build generiert ein Ergebnis, das von allen Browsern verstanden wird.
- Es werden zwei (oder mehr) Varianten der Anwendung gebaut, eine f√ºr die modernen Plattformen, eine f√ºr ... den IE.

---

### Optimierte Builds f√ºr moderne und legacy Browser

Variante zwei hat den Vorteil, dass f√ºr moderne Browser optimierter Code meistens kleiner ist (minify) und von den JavaScript 
Engines oft schneller ausgef√ºhrt wird. 

Es werden also nicht alle Kunden "bestraft", sondern nur die wenigen mit alten Browsern. 

---

### Beispiel

Folgender Code ...

```javascript
class Person {

  firstName = 'Arthur';
  lastName = 'Dent';

  sayName() {
    return `${this.firstName} ${this.lastName}!`
  }
}
```

---

... wird z.B. vom Babel Transpiler in diesen Code umgewandelt, 

```javascript
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Person = function () {
  function Person() {
    _classCallCheck(this, Person);

    this.firstName = 'Arthur';
    this.lastName = 'Dent';
  }

  _createClass(Person, [{
    key: 'sayName',
    value: function sayName() {
      return this.firstName + ' ' + this.lastName + '!';
    }
  }]);

  return Person;
}();
```

den auch ein IE versteht, das kommt also beim Kunden an. 

---

### Sicherheit und Build-Integrit√§t

Auch das Thema Sicherheit ist beim Ausliefern von Webanwendungen ein wichtiger Punkt. 
Ein beliebter Angriffspunkt ist z.B. die Manipulation der ausgelieferten JavaScripts auf einem CDN. 

Es ist schwer, in einem transpilieren und komprimierten Paket etwaige Manipulationen zu erkennen. 

---

### Sicherheit und Build-Integrit√§t

Moderne Browser bieten gegen diesen Angriff einen Schutz durch die sog. 
[Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity). 

Direkt in der Webseite, die diese JavaScript Dateien l√§dt, wird eine Checksumme dieser Datei hinterlegt. 
Passt diese nicht auf die geladene Datei, wird diese sofort verworfen und nicht ausgef√ºhrt. 
Webpack zum Beispiel kann diese Checksummen automatisiert w√§hrend des Builds generieren und ablegen. 




---

### Bau einer PWA

Auch der Bau einer PWA (Progressive Web App), kann durch ein Buildtool sehr erleichter werden. 
Sowohl das aufwendige Generieren eines [Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
als auch der ben√∂tigten Manifest Datei kann automatisiert werden.

---

# Webpack

Webpack ist der aktuell verbreitetste JavaScript Bundler. Mit aktuell ca. 16 Millionen Downloads pro Woche wird er von der Mehrzahl 
aller Webprojekte eingesetzt. 

Die besondere St√§rke von webpack liegt in der extremen Konfigurierbarkeit und Erweiterbarkeit durch Plugins. 

---

# Webpack

<Quote>You can configure that in ...</Quote>
<Quote>We have a plugin for that!</Quote>

Default answers for webpack questions on stackoverflow üòâ. 

---

## St√§rken von webpack

Webpack bietet Unterst√ºtzung f√ºr praktisch jeden Browser (bis hinunter zu IE8) und jede noch so exotische Technologie. 

Diese Folien wurden zum Beispiel mit Markdown geschrieben und von einem Webpack Plugin in das HTML umgewandelt, das jetzt zu sehen ist. 

---

## TODO webpack Konzepte

Entry, Output, Mode, Loader, Plugin

---

<FlexBox alignContent="center" justifyContent="center" height="100%">
  <Image
    src="https://media.giphy.com/media/13ZVRnWnmSMaRy/source.gif"
    alt="Showtime"
    height="50%"
  />
</FlexBox>

---

# Snowpack

Snowpack ist ein relativ junges Projekt (Version 1.0 Januar 2020), das im Gegensatz zu webpack im Kern auf ES Modulen aufbaut.

Damit √ºberl√§sst Snowpack den (modernen) Browsern selbst die Aufgabe, Abh√§ngigkeeiten aufzul√∂sen und die Ladereihenfolge zu bestimmen und √ºbernimmt nur Aufgaben wie das Transpilieren oder das Bereitstellen eines Dev Servers.

---

# Snowpack

Dieser Verzicht auf die Unterst√ºtzung von legacy Browsern (auch hierf√ºr gibt es eine L√∂sung, auf die ich sp√§ter eingehe), erm√∂glicht es Snowpack den Build Schritt komplett zu √ºberspringen.

Dies bringt besonders w√§hrend der Entwicklung enorme Vorteile.

---

## Snowpack in Dev

W√§hrend der Entwicklung kommt es zu praktisch zu keinen merklichen Buildzeiten, da immer nur die eine ge√§nderte Datei gebaut und an den Browser gesendet wird. Der Rest liegt dort ohnehin bereits im Cache.

Dies gilt auch und besonders f√ºr gr√∂√üere, gewachsene Projekte, wo Tools wie webpack mit jeder neu hinzugef√ºgten Datei ein kleines bisschen langsamer werden.

---

<FlexBox alignContent="center" justifyContent="center" height="100%">
  <Image
    src="https://media.giphy.com/media/13ZVRnWnmSMaRy/source.gif"
    alt="Showtime"
    height="50%"
  />
</FlexBox>

---

## Vorteile von Snowpack

- Sehr schneller Dev Build
- Unterst√ºtzung f√ºr die g√§ngigen Formate (TypeScript, JSX, SASS, CSS Module ...) fest eingebaut.
- Wenig Konfiguration notwendig, viele Konventionen
- Aktives √ñkosystem an Erweiterungen (trotzdem kein Vergleich mit webpack)
- Erweiterungen selbst zu entwickeln ist vergleichsweise einfach

---

## Nachteile von Snowpack

- Keine native Unterst√ºtzung f√ºr legacy Browser (= IE)
- Weniger Einstellm√∂glichkeiten - wenn man sie braucht
- Deutlich kleines √ñkosystem im Vergleich zu webpack

---

<FlexBox
  alignContent="center"
  justifyContent="space-around"
  height="90%"
  flexDirection="column"
>
  <Image
    src="/src/assets/snowpack-webpack.png"
    alt="Snowpack vs webpack in downloads"
    height="100%"
  />
  <p>
    <a href="https://www.npmtrends.com/snowpack-vs-webpack" target="_blank">
      Snowpack vs webpack
    </a>
  </p>
</FlexBox>

---

## Snowpack in Produktion

F√ºr den Produktionsbuild erm√∂glicht Snowpack, in den Buildprozess noch einen klassischen Bundler einzuh√§ngen.
Dieser √ºbernimmt dann die Aufgaben wie minification, tree shaking oder Builds f√ºr legacy Browser.

Aktuell werden die Bundler esbuild (modern, extrem schnell, junges Projekt), webpack und rollup unterst√ºtzt.

---

## Snowpack + webpack

Durch die Kombination aus einem sehr schlanken und schnellen Entwicklungsprozess und der M√§chtigkeit und Flexibilit√§t von Webpack in Produktion,
hat er gemeinsame Einsatz von Snowpack und webpack das Potential, auch in gro√üen und komplexen Projekten erfolgreich zu sein.

F√ºr neu startende Projekte kann man durchaus den Einsatz von Snowpack in Betracht ziehen und bei Bedarf webpack f√ºr die Produktion erg√§nzen.
